                        Library Management APi

Library Management System project involves several important concepts and technologies that are cohesively integrated using Mongoose, TypeScript, and Express. The data modeling is handled through Mongoose schemas paired with TypeScript interfaces, ensuring a strict and predictable data structure. The book.model.ts file defines the schema for books, specifying required fields such as title, author, ISBN, genre, copies, and availability. A custom method, updateAvailability, is also implemented to dynamically update the availability status based on the number of available copies. This model is strictly typed using the IBook interface, which provides strong type safety during development.
Similarly, the borrow functionality is structured through the borrow.model.ts and borrow.interface.ts files. The borrow schema references the book model using an ObjectId, enabling document population and relational-like behavior in MongoDB. The schema ensures that a valid book is referenced, a quantity is provided and greater than zero, and a due date is set in the future. The IBorrow interface guarantees that these fields are always present and correctly typed in any borrow record.
The application’s business logic is encapsulated in controller files. In borrow.controller.ts, the POST /borrow endpoint handles the core borrowing logic. It validates the due date, ensures the requested book exists, checks whether there are enough copies available, deducts the quantity from the book’s inventory, updates the availability status, and finally creates a borrow record. If any validation fails, appropriate HTTP error responses are returned with descriptive messages. The GET /borrow endpoint uses MongoDB’s aggregation framework to summarize total borrowed quantities per book, enriching the response with book details like title and ISBN via $lookup, $unwind, and $project stages.
The book.controller.ts file provides complete CRUD support for books. The POST route allows adding new books, while the GET route supports dynamic filtering and searching based on query parameters such as genre, title, author, or availability. Books can be retrieved individually by ID, updated using the PATCH method, or deleted entirely through the DELETE route. Each route is wrapped with consistent error handling and returns structured JSON responses.
The app.ts file is the main configuration entry for the Express app. It sets up middleware to parse JSON bodies and mounts all defined routers (booksRoutes, borrowBook, and borrowSummary) under the /api prefix. A root route provides a basic response to verify the server is running. This app instance is then imported into server.ts, where the server initializes by connecting to MongoDB and starts listening on a designated port. If the connection is successful, it logs a confirmation; otherwise, it captures and logs the error.
A key part of the system is the use of aggregation for borrow summary reporting. By leveraging $group, the app calculates the total number of books borrowed per title. With $lookup, it fetches book information from the related collection, and $unwind ensures the result is flattened for simpler access. $project then shapes the final response, limiting the output to only the necessary fields.
The project demonstrates thoughtful validation and clean architectural separation. Validation logic is built into both the schema definitions and controller logic. All routes consistently use expressive error handling to guide the API consumers. The use of TypeScript throughout enforces consistency, helps catch bugs early, and enhances maintainability. Overall, this system showcases good practices in building RESTful APIs with robust data modeling, modular architecture, and clear separation of concerns.
